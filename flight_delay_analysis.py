# -*- coding: utf-8 -*-
"""code_Jiayin_Ver_after07051826.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jQ7UxFpUGQnw1TgBndCa7dJ0X_qo0yB_

## Content
#### 1 Preparation
#### 2 Data obervation

## 1.Preparation
"""

##for windows
# import wget
# # run once
# wget.download("http://stat-computing.org/dataexpo/2009/carriers.csv")
# wget.download("http://stat-computing.org/dataexpo/2009/plane-data.csv") 
# wget.download( "http://stat-computing.org/dataexpo/2009/airports.csv")
# wget.download("https://raw.githubusercontent.com/KeplerC/Mathematical-Networks/master/Airport-Delay-Analysis/Data/airport_codes.csv") 
# wget.download( "http://stat-computing.org/dataexpo/2009/2008.csv.bz2")
# !mkdir Data
# !move *.csv ./Data
# #!7z x 2008.csv.bz2
# !mkdir Data\trip
# !move .\2008.csv .\Data\trip

#for Linux
!wget http://stat-computing.org/dataexpo/2009/carriers.csv
!wget http://stat-computing.org/dataexpo/2009/plane-data.csv 
!wget http://stat-computing.org/dataexpo/2009/airports.csv
!wget http://stat-computing.org/dataexpo/2009/2008.csv.bz2
!wget https://raw.githubusercontent.com/KeplerC/Mathematical-Networks/master/Airport-Delay-Analysis/Data/airport_codes.csv
!mkdir Data
!mv *.csv ./Data
!bzip2 -d 2008.csv.bz2
!mkdir ./Data/trip
!mv ./2008.csv ./Data/trip

from __future__ import division
import matplotlib.pyplot as plt
from functools import reduce 
from scipy import stats
import pandas as pd
import seaborn as sns
import networkx as nx 
import numpy as np
import os
from time import time
# http://stat-computing.org/dataexpo/2009/the-data.html
def fun_2_prepare(data,N):#historical reason
    return data.sample(N)

"""About the following imports:
* _airports_ contains coordinates for airports in the USA.
* _carriers_ contains airport names and cities that are useful for data merging and indexing.
* _codes_ contains airport codes useful for merging and indexing (Source:http://www.airportcodes.us/us-airports.htm)
"""

# Data imports (files attached in the email assignment)
carriers  = pd.read_csv('Data/carriers.csv')
carriers.columns = ['UniqueCarrier','Description']
carriers.dropna(how="all", inplace=True)
carriers.head()

codes = pd.read_csv('Data/airport_codes.csv') 
codes.head()

codes = codes.set_index('Code').to_dict()

airports  = pd.read_csv('Data/airports.csv')
airports = airports.query("country == 'USA'")
airports.head()

"""#### 1.1 Basic exploration

Just out of curiosity, I plotted the number of airports in each State. There are big states with not that many airports, and smaller states with a large amount of airports.
"""

plt.figure(figsize=(19,5))
airports.state.value_counts().plot(kind='bar')
plt.title('Number of airports by State',fontsize=16)
plt.xlabel('State')
plt.ylabel('Number of Airports')

"""Again, out of curiosity, I plotted the distribution of our airports in question. It follows the known patterns in US American geography and political divisions."""

plt.figure(figsize=(15,10))
plt.scatter(airports.long,airports.lat,s=10,c='grey')
plt.title('Geographical distribution of airports in the dataset',fontsize=16)
plt.show()

airports.head(2)

"""For the centrality index I will only be working with 2008 data."""

trips_08 = pd.read_csv('Data/trip/2008.csv')
pd.set_option('display.max_columns', 30)
print('number of data:', len(trips_08))
trips_08.head(2)

print("The total number of flights was " + str(len(trips_08)) + " whereas the number of not cancelled trips was " +str(trips_08.Cancelled.value_counts()[0]) + ". The percentage of cancellation is " + str(100 - 100*trips_08.Cancelled.value_counts()[0] / len(trips_08)) + " %" )

print('number of airports as destination:',len(pd.unique(trips_08["Dest"])))
print('number of airports as origin:',len(pd.unique(trips_08["Origin"])))
print('number of airports as dest ot origon',len(pd.unique(trips_08["Dest"].append(trips_08["Origin"]))))
print('origin-dest',pd.unique(trips_08["Origin"])[~np.isin(pd.unique(trips_08["Origin"]),pd.unique(trips_08["Dest"]))])
print('dest-origin',pd.unique(trips_08["Dest"])[~np.isin(pd.unique(trips_08["Dest"]),pd.unique(trips_08["Origin"]))])

"""Thus most of the edges are two-way."""

iters=trips_08.groupby(['Origin','Dest']).groups.keys()
print('total traffics:', len(iters))
one_ways=[(x,y) for x,y in  iters if (y,x) not in iters]
print ('number of one way traffic:',len(one_ways))
one_ways[:5]

"""#### 1.3 Data simplification

To simplify our computation we discard the following trips 

*  all trips that has cancelled 
*   all trips whose opposite trip does not exist
"""

def fun_1_simplify_step_1(data, simplify=True):
  if simplify:
      print('number of data:',len(data))
      data = data[data['Cancelled'] == 0]
      print('number of data after drop cancelled:',len(data))
      
      data = data[~data['ArrTime'].isnull()]
      print('number of data after drop no ArrTime:',len(data))
      
      data = data[~data['AirTime'].isnull()]
      print('number of data after drop no AirTime:',len(data))
      
      iters=data.groupby(['Origin','Dest']).groups.keys()
      one_ways=[(x,y) for x,y in  iters if (y,x) not in iters]
      #print(len(one_ways))
      if one_ways:
        data=data[~reduce(lambda x,y:x|y, [(data.Origin==x)&(data.Dest==y) for x,y in one_ways]) ]
      print('number of data after drop one way trips:',len(data))
  else:
    print('data is not simplified')
  return data

trips_08 = pd.read_csv('Data/trip/2008.csv')# little bit slow 30 seconds

trips_08 = fun_1_simplify_step_1(trips_08)# little bit slow, approximate 3 min on colab
trips_08.describe()

data=trips_08.sample(100000)
data=fun_1_simplify_step_1(data)
data.describe()

"""#### 1.4 More observation based on network of data"""

data=trips_08.sample(10000)
data=trips_08

"""For simplicity we build the newrok as a Directed Graph satify the following:


1.  every edge is two way
2.   total number of flights of each *direction* is the weight of 
each *directed*   edge
"""

from datetime import datetime,timedelta


def fun_1_to_three_tuple(df):
  A={}
  A['Distance']=df['Distance']
  A['weight']=df['TotalNumber']
  dt=datetime(year=df['Year'],month=df['Month'],day=df['DayofMonth'],hour=df['CRSArrTime']//100,minute=df['CRSArrTime']%100)
  dt-=datetime(year=df['Year'],month=df['Month'],day=df['DayofMonth'],hour=df['CRSDepTime']//100,minute=df['CRSDepTime']%100)
  #under assumption that the flight speed is smaller than the speed of roation of earth
  if dt<timedelta():
    dt+=timedelta(days=1)
    
  dt-=timedelta(seconds=df['CRSElapsedTime']*60)
  A['RelTime']=dt
  #print(df['Origin'],df['Dest'],dt)
  return (df['Origin'],df['Dest'],A)

def fun_1_to_nodes_dict(G,airports):
  airports=airports.set_index(airports.iata.values)
  A={node:{'pos':(airports.loc[node].long,airports.loc[node].lat)} for node in G.nodes }
  return A

def fun_1_network_build(data):
    temp=data.groupby(['Origin','Dest'],as_index=False).first()
    temp['TotalNumber']=data.groupby(['Origin','Dest'],as_index=False)['FlightNum'].count().FlightNum
    #temp['RelTime']=temp.apply(fun_1_to_three_tuple,axis=1)[2]['RelTime']
    temp.describe()
    G=nx.DiGraph()
    G.add_edges_from(temp.apply(fun_1_to_three_tuple,axis=1))
    nx.set_node_attributes(G,fun_1_to_nodes_dict(G,airports))
    return G,temp

G_08,data_G_08=fun_1_network_build(trips_08)
data_G_08.describe()

data_G_08[((data_G_08.Origin=='ATL')|(data_G_08.Origin=='LAX'))&((data_G_08.Dest=='ATL')|(data_G_08.Dest=='LAX'))]

G_08.edges[('ATL','LAX')]

G_08.edges[('LAX','ATL')]

def fun_1_draw_network(G):
    plt.figure(1,figsize=(12,12)) 
    nx.draw(G.to_undirected(),pos=nx.get_node_attributes(G,'pos'),with_labels=True)
    plt.show()
fun_1_draw_network(G_08)

nx.dag_longest_path(nx.bfs_tree(G_08, 'LAX'))

"""#### 1.5 Add distance between air ports"""

import geopy.distance
from itertools import product
from collections import defaultdict
class keydefaultdict(defaultdict):
    def __missing__(self, key):
        if self.default_factory is None:
            raise KeyError( key )
        else:
            ret = self[key] = self.default_factory(key)
            return ret

def fun1_dist(data,airports):
    temp=pd.unique(data["Origin"].append(data["Dest"]))
    airports_in_data=airports[airports['iata'].isin(temp) ].set_index('iata')
    print(len(airports_in_data))
    airports_in_data.head(3)
    calculator=keydefaultdict(lambda x: geopy.distance.vincenty(airports_in_data.loc[x[0]][['lat','long']],
                                                             airports_in_data.loc[x[1]][['lat','long']]).mi)
    data["Dist"]=data.apply(lambda x:calculator[(x['Origin'],x['Dest'])],axis=1)
    
    return

data=fun_2_prepare(trips_08,400)
data.head()

t0=time()
dist_data=fun1_dist(data,airports)
t1=time()
print("t:",t1-t0)
data.head()

"""####1.6 Add abosulte time for trip_08"""

# from matplotlib_venn import venn3


# def fun_1_time_isnull_venn3(data,reasons):
    
                 
#     delays_bools=[data[data[reason].isnull()] for reason in reasons]
#     #total_delays_cases=reduce( lambda x,y:x|y,delays_bools).value_counts()[True]
    
    
    
#     A={}
#     B=set()
#     for reason,deley_data in zip(reasons,delays_bools):
#                   A[reason]=set(deley_data.index)
#                   B=B|A[reason]
#                   print('missing data with column',reason,len(A[reason]))
#     print("problematic cases has rate:","{:.1%}".format(len(B)/len(data)))       
   
#     plt.figure(figsize=(4,4))
#     v = venn3([x[1] for x in sorted(list(A.items()),key=lambda x: -len(x[1]))[:3]],
#               [x[0] for x in sorted(list(A.items()),key=lambda x: -len(x[1]))[:3]],
#               subset_label_formatter=lambda x: f"{(x/len(B)):1.0%}")
#     plt.show()

# fun_1_time_isnull_venn3(trips_08,['DepTime',	'CRSDepTime',	'ArrTime',	'CRSArrTime'])

G=G_08.copy()
source='LAX'

def fun_1_abstime(G,source):
    A=dict(nx.bfs_successors(G, source=source))
    G.nodes[source]['TimeModifyer']=timedelta()
    # TimeModifyer term has following property: arr+arr_timemod=dep+dep_timemod+elaps
    # rel has property: rel=arr-dep-elaps
    # thus arr_timemod=dep_timemod-rel
    def fun_1_BFS(tree,origin):
        if origin not in tree:
            return
        else:
          for dest in A[origin]:
              #print(origin)
              #G.nodes[origin]['TimeModifyer']-G.edges[(origin,dest)]['RelTime']
              G.nodes[dest]['TimeModifyer']=G.nodes[origin]['TimeModifyer']-G.edges[(origin,dest)]['RelTime']
              fun_1_BFS(tree,dest)

    fun_1_BFS(A,source)

fun_1_abstime(G,source)

print(G.nodes['LAX'])
print(G.nodes['ATL'])
print(G.edges[('LAX','ATL')])
print(G.edges[('ATL','LAX')])

def fun_1_draw_network_nodes_attr(G,attr):
    plt.figure(1,figsize=(12,12)) 
    labels={node:value.total_seconds()/3600 for node,value in nx.get_node_attributes(G,attr).items()}
    #print(labels)
    nx.draw(G.to_undirected(),pos=nx.get_node_attributes(G,'pos'),labels=labels)
    plt.show()
fun_1_draw_network_nodes_attr(G,'TimeModifyer')

#write a function fun_1_abstime()
#
##------------call format-------------------
#>fun_1_abstime(trip_08)
#>trip_08["AbsDepTime"].loc[1]==3903
#>trip_08["AbsArrTime"].loc[1]==4031
#>trip_08["AbsCRSDepTime"].loc[1]==3895
#>trip_08["AbsCRSArrTime"].loc[1]==4045

# suppose trip_08.loc[1] is the following
#     Year	Month	DayofMonth	DayOfWeek	DepTime	CRSDepTime	ArrTime	CRSArrTime	UniqueCarrier	FlightNum	TailNum	ActualElapsedTime	CRSElapsedTime	AirTime	ArrDelay	DepDelay	Origin	Dest	Distance	TaxiIn	TaxiOut	Cancelled	CancellationCode	Diverted	CarrierDelay	WeatherDelay	NASDelay	SecurityDelay	LateAircraftDelay
#0	  2008	1	    3	          4	        2003.0	1955	      2211.0	2225	      WN	          335	       N712SW	 128.0	          150.0	           116.0	-14.0	    8.0	      IAD	    TPA	  810	      4.0	     8.0	   0	       NaN	            0	        NaN	          NaN	          NaN	      NaN	           NaN
# Explanation 
#relative to local time, the Deptime has been 2days 20 hours 3min after 2018Jan1st00:00 which is 2*1440+20*60+3=4083, 
#origin IAD is in VA(GMT-4) so covert to PSD, time zone of los angeles(GMT-7) is 4083-180= 3903
#Dest in TPA is again in GMT -4. So AbsArrtime is 395  

def fun_1_abstime_wrong(demo):
  l1=[]
  for i in list(demo.index):
    a = demo.loc[i,"DayofMonth"]-1
    b = int((demo.loc[i,"DepTime"])/100)
    c = floor(demo.loc[i,"DepTime"])%100
    d = demo.loc[i,"Origin"]
    e = int((airports[airports.iata==d].long)/15)
    f = a*1440+b*60+c+e*60
    l1.append(f)
  demo["AbsDepTime"]=l1
  l2=[]
  for i in list(demo.index):
    a = demo.loc[i,"DayofMonth"]-1
    b = int((demo.loc[i,"ArrTime"])/100)
    c = floor(demo.loc[i,"ArrTime"])%100 
    d = demo.loc[i,"Origin"]
    e = int((airports[airports.iata==d].long)/15)
    f = a*1440+b*60+c+e*60
    l2.append(f)
  demo["AbsArrTime"]=l2
  l3=[]
  for i in list(demo.index):
    a = demo.loc[i,"DayofMonth"]-1
    b = int((demo.loc[i,"CRSDepTime"])/100)
    c = floor(demo.loc[i,"CRSDepTime"])%100 
    d = demo.loc[i,"Origin"]
    e = int((airports[airports.iata==d].long)/15)
    f = a*1440+b*60+c+e*60
    l3.append(f)
  demo["AbsCRSDepTime"]=l3
  l4=[]
  for i in list(demo.index):
    a = demo.loc[i,"DayofMonth"]-1
    b = int((demo.loc[i,"CRSArrTime"])/100)
    c = floor(demo.loc[i,"CRSArrTime"])%100 
    d = demo.loc[i,"Origin"]
    e = int((airports[airports.iata==d].long)/15)
    f = a*1440+b*60+c+e*60
    l4.append(f)
  #demo["AbsCRSArrTime"]=l4

"""#### 1.9 Time series of Airports"""

data=trips_08
airport='LAX'

def fun_1_ts_gen_Dest(df):
  
  dt=datetime(year=df['Year'],month=df['Month'],day=df['DayofMonth'],hour=df['CRSArrTime']//100,minute=df['CRSArrTime']%100)
  dt-=datetime(year=df['Year'],month=df['Month'],day=df['DayofMonth'],hour=df['CRSDepTime']//100,minute=df['CRSDepTime']%100)
  #under assumption that the flight speed is smaller than the speed of roation of earth
  if dt<timedelta():
    dt+=timedelta(days=1)
    
  dt-=timedelta(seconds=df['CRSElapsedTime']*60)
  A['RelTime']=dt
  #print(df['Origin'],df['Dest'],dt)
  return (df['Origin'],df['Dest'],A)
  return

data[data.Dest==airport].apply(fun)

"""## 2 Linear regrssion on flights with delay feature.

first observation is that the threshhold for arr_dely is 15
"""

list(trips_08.columns.values)
trips_08.head()

def fun_2(sample_data):
    columns=[
'ArrDelay',
 'DepDelay',
 'Distance',
 'TaxiIn',
 'TaxiOut',
 'CarrierDelay',
 'WeatherDelay',
 'NASDelay',
 'SecurityDelay',
 'LateAircraftDelay']
    sample_data['threshhold']=(sample_data['CarrierDelay'].isnull() &
                                    sample_data['WeatherDelay'].isnull() &
                                   sample_data['NASDelay'].isnull() &
                                   sample_data['SecurityDelay'].isnull() &
                                   sample_data['LateAircraftDelay'].isnull())
                    
    delay_threshhold=sample_data[sample_data['threshhold']]
    delay_over_threshhold=sample_data[~sample_data['threshhold']]
    temp=np.array(np.random.random(len(delay_threshhold)))
    plt.figure(figsize=(10,10))
    plt.scatter(delay_threshhold ['ArrDelay'],temp, c = 'grey', s = 8)
    
    plt.xlim([-50,50])
    #plt.ylim([-20,60])
    #plt.title('Total delays relative to travel distance between airports',fontsize=16)

    
    temp=np.array(np.random.random(len(delay_over_threshhold)))
    plt.scatter(delay_over_threshhold ['ArrDelay'],temp, c = 'green', s = 8)
    
    plt.xlabel('arrdelay',fontsize=12)
    plt.ylabel('random number',fontsize=12)
    
    plt.show()
    
    
    
    delay_threshhold.head(100)    
    print("avg delay rate:",len(delay_over_threshhold)/len(sample_data))
    return delay_threshhold,delay_over_threshhold

sec2_sample_data=fun_2_prepare(trips_08,1000)# little bit slow run once

delays_less,delays_over=fun_2(sec2_sample_data)

"""try to figure out the factor that contributed to arr_delay. Note that arr_delay=c_delay+w_delay+n_delay+l_delat+s_delay"""

delays_over.head()

from matplotlib_venn import venn3
from functools import reduce 

def fun_2_delay_venn3(data,reasons):
    
                        
    
    delays_bools=[data[data[reason]>0.1] for reason in reasons]
    
    #print(delays_bools[1])
    A={}
    for reason,deley_data in zip(reasons,delays_bools):
                  A[reason]=set(deley_data.index)
                  #print(reason, len(A[reason]),"percent:",round(len(A[reason])/len(data)*100,1))
    
    plt.figure(figsize=(4,4))
    v = venn3([x[1] for x in sorted(list(A.items()),key=lambda x: -len(x[1]))[:3]],
              [x[0] for x in sorted(list(A.items()),key=lambda x: -len(x[1]))[:3]],
              subset_label_formatter=lambda x: f"{(x/len(data)):1.0%}")
    plt.show()

delays_reasons=[
    'CarrierDelay',
 'WeatherDelay',
 'NASDelay',
 'SecurityDelay',
 'LateAircraftDelay'
]
fun_2_delay_venn3(delays_over,delays_reasons)

